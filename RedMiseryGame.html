<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

<body style="background-color: rgb(48, 41, 49); overflow: hidden;">

    <div id="Game" class=""
        style=" border: 10px solid rgb(227, 227, 230); position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); position: absolute; transform-origin: center center; background-color: lightsalmon;">
        <canvas id="GameCanvas" style="width: 100%; height: 100%; position: absolute; top: 0;"></canvas>
        <div
            style="position: absolute; background-size: cover; background-image: url(Smog.png); width: 100%; height: 100%; margin: 0; top: 0; left: 0; z-index: -1;">
        </div>
        <div
            style="position: absolute; background-size: cover; background-image: url(Cliffs.png); width: 100%; height: 100%; margin: 0; top: 0; z-index: -1;">
        </div>

    </div>

</body>


<style>
</style>

<script>
    let game = document.getElementById("Game");
    let gameCanvas = document.getElementById("GameCanvas");
    const ctx = gameCanvas.getContext('2d');

    function GameEngine() {
        this.gameObjects = [];

        this.lastTime = 0;
        this.targetFPS = 30;
        this.frameInterval = 1000 / this.targetFPS;
        this.nextFrameCount = false;

        this.gameLoop = function (timeStamp) {
            const deltaTime = timeStamp - this.lastTime;

            if (deltaTime >= this.frameInterval) {
                this.lastTime = timeStamp;
                this.nextFrameCount = true;

                ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

                this.gameObjects.forEach(element => {
                    try {
                        element.draw();
                    } catch (e) {
                        console.log(e);
                    }

                });
            }
        }

    }

    let gameEngine = new GameEngine;

    function startGameEngine() {
        function loop(timeStamp) {
            gameEngine.gameLoop(timeStamp);
            requestAnimationFrame(loop);
        }
        requestAnimationFrame(loop);
    }
    startGameEngine();




    function resizeGame() {
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;
        gameCanvas.width = screenHeight * 1.6;
        gameCanvas.height = screenHeight;
        game.style.height = screenHeight;
        game.style.width = (screenHeight * 1.6);
    }

    resizeGame();
    window.addEventListener('resize', resizeGame);


    function GameObject(iX, iY, imageUrl, width, height, type) {
        this.x = iX;
        this.y = iY;
        this.imageUrl = imageUrl;
        this.image = new Image();
        this.width = width;
        this.height = height;
        this.type = type;



        if (imageUrl != "" && type == "image") {
            this.image.src = imageUrl;
            this.image.onload = () => {
                this.draw();
            }
        }


        gameEngine.gameObjects.push(this);


        let regulateX = gameCanvas.height / 100;
        let regulateY = gameCanvas.height / 100;

        this.draw = function () {
            if (this.type == "image") {

                //
                ctx.drawImage(this.image, this.x * regulateX, this.y * regulateY, this.width * regulateX, this.height * regulateY);

            } else if (this.type == "text") {

                

                ctx.font = this.width + "px Impact";
                ctx.lineWidth = 5;
                ctx.strokeStyle = "black";
                ctx.strokeText(this.imageUrl, this.x * regulateX, this.y * regulateY);
                ctx.fillStyle = "yellow";
                ctx.fillText(this.imageUrl, this.x * regulateX, this.y * regulateY);


            } else if (this.type == "textbox") {

                //GetMeasurments
                ctx.font = this.width + "px Impact";
                let padding = 10;
                let textHeight = this.width;
                let textWidth = ctx.measureText(this.imageUrl).width;
                ctx.lineWidth = 5;

                //Draw The Rectangle
                ctx.fillStyle = 'black'; 
                ctx.fillRect(this.x * regulateX - padding, this.y * regulateY - textHeight, textWidth + padding * 2, textHeight + padding);


                //Draw the Text

                ctx.strokeStyle = "black";
                ctx.strokeText(this.imageUrl, this.x * regulateX, this.y * regulateY);
                ctx.fillStyle = "yellow";
                ctx.fillText(this.imageUrl, this.x * regulateX, this.y * regulateY);
            }
        }

    }

    class Character extends GameObject {
        constructor(iName, iHP, iMP, iStr, iMag, iEnd, iAgi, iLuc, iX, iY, iImage, iWidth, iHeight, type) {
            super(iX, iY, iImage, iWidth, iHeight, type);
            this.name = iName;
            this.hitPoints = iHP;
            this.maxHitPoints = iHP;
            this.manaPoints = iMP;
            this.maxManaPoints = iMP;
            this.str = iStr;
            this.mag = iMag;
            this.end = iEnd;
            this.agi = iAgi;
            this.luc = iLuc;
            this.x = iX;
            this.y = iY;
            this.imageVal = iImage;
            this.xScale = iWidth;
            this.yScale = iHeight;
            this.initiative = 0;

            this.TakeDamage = function (iDamage) {
                let damage = iDamage;
                damage -= this.end;
                if (damage < 1) {
                    damage = 1;
                }
                this.hitPoints -= damage;
                // console.log(this.name + " took " + damage + " damage. They have " + this.hitPoints + " HP left");
            }

            this.AgilityCheck = function(){
                return this.agi + Roll(1,100);
            }

            this.RollInitiative = function(){
                this.initiative = this.agi + Roll(1,100);
                return this.initiative;
            }
            

            //This function needs to be fixed badly!
            this.hop = function(){
                let originalPosition = this.y;
                let hopPeak = this.y-15;
                while (this.y > hopPeak){
                    setTimeout(this.y--, 333)

                }
                while (this.y < originalPosition){
                        this.y++;
                }
            }

        }
    }

    ///Damage Types: 0 = Slashing, 1 = Piercing, 2 = Bludgeoning, 3 = Fire


    //construction character(iName, iHP, iMP, iStr, iMag, iEnd, iAgi, iLuc, iX, iY, iImage, iWidth, iHeight, type)
    let Orobas = new Character("Orobas", 100, 30, 20, 8, 24, 7, 12, 10, 45, "OrobasPlaceholder.png", 60, 45, "image");
    let Griffon = new Character("Griffon", 80, 50, 18, 14, 18, 12, 10, 70, 50, "GriffonPlaceholder.png", 26.2, 39.4, "image");
    let Mazneth = new Character("Mazneth", 64, 0, 7, 1, 8, 32, 18, 110, 50, "MaznethPlaceholder.png", 22.5, 35.5, "image");

    let grunt1 = new Character("Grunt", 60, 20, 16, 12, 12, 10, 12, 40, 30, "GruntChuddie.png", 14.6, 19.7, "image");
    let grunt1HealthStats = new GameObject(40, 30, (grunt1.hitPoints + "/" + grunt1.maxHitPoints + " HP"), 20, 20, "text");
    let grunt2 = new Character("Grunt", 60, 20, 16, 12, 12, 10, 12, 70, 30, "GruntChuddie.png", 14.6, 19.7, "image");
    let grunt2HealthStats = new GameObject(70, 30, (grunt2.hitPoints + "/" + grunt2.maxHitPoints + " HP"), 20, 20, "text");
    let grunt3 = new Character("Grunt", 60, 20, 16, 12, 12, 10, 12, 110, 30, "GruntChuddie.png", 14.6, 19.7, "image");
    let grunt3HealthStats = new GameObject(110, 30, (grunt3.hitPoints + "/" + grunt3.maxHitPoints + " HP"), 20, 20, "text");

    // let OrobasPortrait = new GameObject(1, 1, "OrobasPortrait.png", 20, 20, "image");
    let OrobasHealthStats = new GameObject(30, 90, (Orobas.hitPoints + "/" + Orobas.maxHitPoints + " HP"), 10, 10, "text");
    let OrobasManaStats = new GameObject(30, 95, (Orobas.manaPoints + "/" + Orobas.maxManaPoints + " MP"), 10, 10, "text");
    let GriffonHealthStats = new GameObject(75, 90, (Griffon.hitPoints + "/" + Griffon.maxHitPoints + " HP"), 10, 10, "text");
    let GriffonManaStats = new GameObject(75, 95, (Griffon.manaPoints + "/" + Griffon.maxManaPoints + " MP"), 10, 10, "text");
    let MaznethHealthStats = new GameObject(110, 90, (Mazneth.hitPoints + "/" + Mazneth.maxHitPoints + " HP"), 10, 10, "text");
    let MaznethManaStats = new GameObject(110, 95, (Mazneth.manaPoints + "/" + Mazneth.maxManaPoints + " MP"), 10, 10, "text");

    let filledText = new GameObject(50, 50, (Mazneth.hitPoints + "/" + Mazneth.maxHitPoints + " HPassdsdsa"), 30, 10, "textbox");


    let party = [Orobas, Griffon, Mazneth];

    let enemies = [grunt1, grunt2, grunt3];

    function TurnKeeper(){
        this.totalTurns = 0;
        this.currentTurn = 0;
        this.turnCharacter = [];
        this.everyone = [];
        
        this.rollInitiative = function(){
            totalTurns = party.length + enemies.length;
            this.everyone = party.concat(enemies);
            this.everyone.forEach(token => {token.RollInitiative()})
            this.everyone.sort((a, b) => a.initiative - b.initiative);
            xPrinter = 5;
            yprinter = 10;
            let initiativeTowerText = new GameObject(xPrinter, yprinter, ("Turn Order"), 20, 20, "text");
            this.everyone.forEach(token => {
                yprinter += 3;
                console.log(token.initiative);
                let initiativeTowerText = new GameObject(xPrinter, yprinter, (token.name + ""), 20, 20, "text");
            })
            

        }

        this.passTurn = function(){
            this.everyone.push(this.everyone.shift());
        }
    }



    let turnkeeper = new TurnKeeper;
    turnkeeper.rollInitiative();

    document.addEventListener('keydown', function (event) {
        if (event.key === " ") {
            Bite();
            turnkeeper.passTurn();
        }
    })

    class Selecter extends GameObject {
        constructor(iX, iY, iImage, iWidth, iHeight, type) {
            super(iX, iY, iImage, iWidth, iHeight, type);


            this.selectedIndex = 0;
            this.maxIndex = 0;
            this.active = false;
            this.livingEnemies = [];

            this.CountEnemies = function () {
                this.livingEnemies = [];
                enemies.forEach((enemy) => {
                    if (enemy.hitPoints > 0){
                        this.livingEnemies.push(enemy);
                    }
                    
                });

                this.selectedIndex = 0;
                if (this.livingEnemies.length > 0){
                    this.maxIndex = 2;
                    this.active = true;
                    this.x = this.livingEnemies[this.selectedIndex].x-15;
                    this.y = this.livingEnemies[this.selectedIndex].y-15;
                } else if (this.livingEnemies.length <= 0){
                    this.active = false;
                    this.y = -100;
                }

            }

            this.NextEnemy = function(){

                if(this.selectedIndex < this.maxIndex){
                    this.selectedIndex++;
                    let g = this.livingEnemies[0].x;
                    this.x = this.livingEnemies[this.selectedIndex].x-15;
                    this.y = this.livingEnemies[this.selectedIndex].y-15;
                    // console.log("selected Next Enemy. SelectedIndex: " + this.selectedIndex);
                    var audio = new Audio('MenuMove.wav');
                    audio.play();
                }
            }
            this.PrevEnemy = function(){

                if(this.selectedIndex > 0){
                    this.selectedIndex--;
                    this.x = this.livingEnemies[this.selectedIndex].x-15;
                    this.y = this.livingEnemies[this.selectedIndex].y-15;
                    var audio = new Audio('MenuMove.wav');
                    // console.log("selected Previous Enemy. SelectedIndex: " + this.selectedIndex);
                    audio.play();
                }
            }

        }
    }

    let selecter = new Selecter(50, 50, "Strike.gif", 50, 50, "image");
    selecter.CountEnemies();

    document.addEventListener('keydown', function (event) {
        if (event.key === "ArrowRight") {
            selecter.NextEnemy();
        }
    })

    document.addEventListener('keydown', function (event) {
        if (event.key === "ArrowLeft") {
            selecter.PrevEnemy();
        }
    })


    function Bite() {
        let target;

        Orobas.hop();
        target = selecter.livingEnemies[selecter.selectedIndex];


        if (target == null) { return }

        let targetX = target.x;
        let targetY = target.y;
        let targetW = target.width;
        let targetH = target.height;
        target.hitPoints -= Roll(8,6);


        //Optimize to have stats be a child of the character object, and possibly make a special class for enemies?
        if (target.hitPoints <= 0) { target.height = 0; }
        grunt1HealthStats.imageUrl = (grunt1.hitPoints + "/" + grunt1.maxHitPoints + " HP");
        grunt2HealthStats.imageUrl = (grunt2.hitPoints + "/" + grunt2.maxHitPoints + " HP");
        grunt3HealthStats.imageUrl = (grunt3.hitPoints + "/" + grunt3.maxHitPoints + " HP");



        let mauling = new GameObject(targetX, targetY, "Bite.gif", 15, 20, "image");
        const clearMauling = setTimeout(clearMaulingFunction, 500);
        let biteSounds = ['Maul.wav','Bite.wav']
        
        var audio = new Audio(biteSounds[Roll(1,2)]);
        audio.play();
        function clearMaulingFunction() {
            mauling.height = 0;
        }
        selecter.CountEnemies();
    }

    function UpdateGame() {

        party[Roll(1,3)].TakeDamage(Roll(1,50));

        let game = document.getElementById("Game");
        let gamePrint = "";
        party.forEach(element => {
            gamePrint += element.name + ":  -  HP:" + element.hitPoints + "/" + element.maxHitPoints + "  -  SP:" + element.manaPoints + "/" + element.maxManaPoints;
            gamePrint += "<br>";
        });
        enemies.forEach(element => {
            gamePrint += element.name + ":  -  HP:" + element.hitPoints + "/" + element.maxHitPoints + "  -  SP:" + element.manaPoints + "/" + element.maxManaPoints;
            gamePrint += "<br>";
        });

    }


    function Roll(count, sides) {
        let total = 0;
        for (let i = 0; i < count; i++){
            total += Math.floor(Math.random() * sides);
        }
        return total;
    }
    


</script>


<!-- 

Acknowledgements:

This code was assisted by online resources including W3Schools, StackOverflow, ChatGPT, and some others.
That being said I made sure to understand how the code works, as designing my game engine has the main idea of having maximum control, relying on unknown code would go against the point.

I'm probably rambling in my own code commends but honestly I'm really tired and this project had me tearing my hair out at points. This is definitely something I'm going to continue to work on past the semester. Finally making a game engine for my projects is really exciting me.

-->